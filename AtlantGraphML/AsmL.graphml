<?xml version = '1.0' encoding = 'ISO-8859-1' ?>
<graphml xmlns:xsi = 'http://www.w3.org/2001/XMLSchema-instance' xsi:schemaLocation = 'http://graphml.graphdrawing.org/xmlnshttp://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd'>
  <key id = 'label' for = 'node' attr.name = 'label' attr.type = 'string'/>
  <graph id = 'AsmLGraph' edgedefault = 'undirected'>
    <edge id = 'Body_extends_LocatedElement' source = 'class_AsmL::Body' target = 'class_AsmL::LocatedElement'/>
    <edge id = 'InWhereHolds_extends_LocatedElement' source = 'class_AsmL::InWhereHolds' target = 'class_AsmL::LocatedElement'/>
    <edge id = 'AsmLFile_extends_LocatedElement' source = 'class_AsmL::AsmLFile' target = 'class_AsmL::LocatedElement'/>
    <edge id = 'AsmLElement_extends_LocatedElement' source = 'class_AsmL::AsmLElement' target = 'class_AsmL::LocatedElement'/>
    <edge id = 'VarDeclaration_extends_AsmLElement' source = 'class_AsmL::VarDeclaration' target = 'class_AsmL::AsmLElement'/>
    <edge id = 'Namespace_extends_AsmLElement' source = 'class_AsmL::Namespace' target = 'class_AsmL::AsmLElement'/>
    <edge id = 'Structure_extends_AsmLElement' source = 'class_AsmL::Structure' target = 'class_AsmL::AsmLElement'/>
    <edge id = 'VarOrCase_extends_LocatedElement' source = 'class_AsmL::VarOrCase' target = 'class_AsmL::LocatedElement'/>
    <edge id = 'Case_extends_VarOrCase' source = 'class_AsmL::Case' target = 'class_AsmL::VarOrCase'/>
    <edge id = 'Class_extends_AsmLElement' source = 'class_AsmL::Class' target = 'class_AsmL::AsmLElement'/>
    <edge id = 'VarOrMethod_extends_LocatedElement' source = 'class_AsmL::VarOrMethod' target = 'class_AsmL::LocatedElement'/>
    <edge id = 'Enumeration_extends_AsmLElement' source = 'class_AsmL::Enumeration' target = 'class_AsmL::AsmLElement'/>
    <edge id = 'Enumerator_extends_LocatedElement' source = 'class_AsmL::Enumerator' target = 'class_AsmL::LocatedElement'/>
    <edge id = 'Function_extends_AsmLElement' source = 'class_AsmL::Function' target = 'class_AsmL::AsmLElement'/>
    <edge id = 'Method_extends_Function' source = 'class_AsmL::Method' target = 'class_AsmL::Function'/>
    <edge id = 'Parameter_extends_LocatedElement' source = 'class_AsmL::Parameter' target = 'class_AsmL::LocatedElement'/>
    <edge id = 'Main_extends_Function' source = 'class_AsmL::Main' target = 'class_AsmL::Function'/>
    <edge id = 'Initially_extends_LocatedElement' source = 'class_AsmL::Initially' target = 'class_AsmL::LocatedElement'/>
    <edge id = 'Rule_extends_LocatedElement' source = 'class_AsmL::Rule' target = 'class_AsmL::LocatedElement'/>
    <edge id = 'SkipRule_extends_Rule' source = 'class_AsmL::SkipRule' target = 'class_AsmL::Rule'/>
    <edge id = 'Step_extends_Rule' source = 'class_AsmL::Step' target = 'class_AsmL::Rule'/>
    <edge id = 'StepUntilFixPoint_extends_Step' source = 'class_AsmL::StepUntilFixPoint' target = 'class_AsmL::Step'/>
    <edge id = 'StepExpression_extends_Step' source = 'class_AsmL::StepExpression' target = 'class_AsmL::Step'/>
    <edge id = 'StepWhile_extends_StepExpression' source = 'class_AsmL::StepWhile' target = 'class_AsmL::StepExpression'/>
    <edge id = 'StepUntil_extends_StepExpression' source = 'class_AsmL::StepUntil' target = 'class_AsmL::StepExpression'/>
    <edge id = 'StepForEach_extends_Step' source = 'class_AsmL::StepForEach' target = 'class_AsmL::Step'/>
    <edge id = 'MethodInvocation_extends_Rule' source = 'class_AsmL::MethodInvocation' target = 'class_AsmL::Rule'/>
    <edge id = 'UpdateRule_extends_Rule' source = 'class_AsmL::UpdateRule' target = 'class_AsmL::Rule'/>
    <edge id = 'UpdateVarRule_extends_UpdateRule' source = 'class_AsmL::UpdateVarRule' target = 'class_AsmL::UpdateRule'/>
    <edge id = 'UpdateFieldRule_extends_UpdateRule' source = 'class_AsmL::UpdateFieldRule' target = 'class_AsmL::UpdateRule'/>
    <edge id = 'UpdateMapRule_extends_UpdateRule' source = 'class_AsmL::UpdateMapRule' target = 'class_AsmL::UpdateRule'/>
    <edge id = 'ChooseRule_extends_Rule' source = 'class_AsmL::ChooseRule' target = 'class_AsmL::Rule'/>
    <edge id = 'ForallRule_extends_Rule' source = 'class_AsmL::ForallRule' target = 'class_AsmL::Rule'/>
    <edge id = 'ConditionalRule_extends_Rule' source = 'class_AsmL::ConditionalRule' target = 'class_AsmL::Rule'/>
    <edge id = 'ElseIf_extends_ConditionalRule' source = 'class_AsmL::ElseIf' target = 'class_AsmL::ConditionalRule'/>
    <edge id = 'ReturnRule_extends_Rule' source = 'class_AsmL::ReturnRule' target = 'class_AsmL::Rule'/>
    <edge id = 'AddRule_extends_Rule' source = 'class_AsmL::AddRule' target = 'class_AsmL::Rule'/>
    <edge id = 'RemoveRule_extends_Rule' source = 'class_AsmL::RemoveRule' target = 'class_AsmL::Rule'/>
    <edge id = 'Type_extends_AsmLElement' source = 'class_AsmL::Type' target = 'class_AsmL::AsmLElement'/>
    <edge id = 'NamedType_extends_Type' source = 'class_AsmL::NamedType' target = 'class_AsmL::Type'/>
    <edge id = 'MapType_extends_Type' source = 'class_AsmL::MapType' target = 'class_AsmL::Type'/>
    <edge id = 'TupletType_extends_Type' source = 'class_AsmL::TupletType' target = 'class_AsmL::Type'/>
    <edge id = 'SetType_extends_Type' source = 'class_AsmL::SetType' target = 'class_AsmL::Type'/>
    <edge id = 'SequenceType_extends_Type' source = 'class_AsmL::SequenceType' target = 'class_AsmL::Type'/>
    <edge id = 'Term_extends_LocatedElement' source = 'class_AsmL::Term' target = 'class_AsmL::LocatedElement'/>
    <edge id = 'VarTerm_extends_Term' source = 'class_AsmL::VarTerm' target = 'class_AsmL::Term'/>
    <edge id = 'Operator_extends_Term' source = 'class_AsmL::Operator' target = 'class_AsmL::Term'/>
    <edge id = 'MapTerm_extends_Term' source = 'class_AsmL::MapTerm' target = 'class_AsmL::Term'/>
    <edge id = 'TulpletTerm_extends_Term' source = 'class_AsmL::TulpletTerm' target = 'class_AsmL::Term'/>
    <edge id = 'MethodCallTerm_extends_Term' source = 'class_AsmL::MethodCallTerm' target = 'class_AsmL::Term'/>
    <edge id = 'NewInstance_extends_MethodCallTerm' source = 'class_AsmL::NewInstance' target = 'class_AsmL::MethodCallTerm'/>
    <edge id = 'PredicateTerm_extends_Term' source = 'class_AsmL::PredicateTerm' target = 'class_AsmL::Term'/>
    <edge id = 'ForAllTerm_extends_PredicateTerm' source = 'class_AsmL::ForAllTerm' target = 'class_AsmL::PredicateTerm'/>
    <edge id = 'ExistsTerm_extends_PredicateTerm' source = 'class_AsmL::ExistsTerm' target = 'class_AsmL::PredicateTerm'/>
    <edge id = 'AnyIn_extends_PredicateTerm' source = 'class_AsmL::AnyIn' target = 'class_AsmL::PredicateTerm'/>
    <edge id = 'SetTerm_extends_Term' source = 'class_AsmL::SetTerm' target = 'class_AsmL::Term'/>
    <edge id = 'EnumerateSet_extends_SetTerm' source = 'class_AsmL::EnumerateSet' target = 'class_AsmL::SetTerm'/>
    <edge id = 'RangeSet_extends_SetTerm' source = 'class_AsmL::RangeSet' target = 'class_AsmL::SetTerm'/>
    <edge id = 'AlgorithmSet_extends_SetTerm' source = 'class_AsmL::AlgorithmSet' target = 'class_AsmL::SetTerm'/>
    <edge id = 'SequenceTerm_extends_Term' source = 'class_AsmL::SequenceTerm' target = 'class_AsmL::Term'/>
    <edge id = 'EnumerateSequence_extends_SequenceTerm' source = 'class_AsmL::EnumerateSequence' target = 'class_AsmL::SequenceTerm'/>
    <edge id = 'RangeSequence_extends_SequenceTerm' source = 'class_AsmL::RangeSequence' target = 'class_AsmL::SequenceTerm'/>
    <edge id = 'Constant_extends_Term' source = 'class_AsmL::Constant' target = 'class_AsmL::Term'/>
    <edge id = 'BooleanConstant_extends_Constant' source = 'class_AsmL::BooleanConstant' target = 'class_AsmL::Constant'/>
    <edge id = 'IntegerConstant_extends_Constant' source = 'class_AsmL::IntegerConstant' target = 'class_AsmL::Constant'/>
    <edge id = 'StringConstant_extends_Constant' source = 'class_AsmL::StringConstant' target = 'class_AsmL::Constant'/>
    <edge id = 'NullConstant_extends_Constant' source = 'class_AsmL::NullConstant' target = 'class_AsmL::Constant'/>
    <edge id = 'referenceEdge_Body2Rule' source = 'class_AsmL::Body' target = 'class_AsmL::Rule'/>
    <edge id = 'referenceEdge_InWhereHolds2Term' source = 'class_AsmL::InWhereHolds' target = 'class_AsmL::Term'/>
    <edge id = 'referenceEdge_AsmLFile2AsmLElement' source = 'class_AsmL::AsmLFile' target = 'class_AsmL::AsmLElement'/>
    <edge id = 'referenceEdge_VarDeclaration2Type' source = 'class_AsmL::VarDeclaration' target = 'class_AsmL::Type'/>
    <edge id = 'referenceEdge_Structure2VarOrCase' source = 'class_AsmL::Structure' target = 'class_AsmL::VarOrCase'/>
    <edge id = 'referenceEdge_Case2VarDeclaration' source = 'class_AsmL::Case' target = 'class_AsmL::VarDeclaration'/>
    <edge id = 'referenceEdge_Class2VarOrMethod' source = 'class_AsmL::Class' target = 'class_AsmL::VarOrMethod'/>
    <edge id = 'referenceEdge_Enumeration2Enumerator' source = 'class_AsmL::Enumeration' target = 'class_AsmL::Enumerator'/>
    <edge id = 'referenceEdge_Function2Body' source = 'class_AsmL::Function' target = 'class_AsmL::Body'/>
    <edge id = 'referenceEdge_Method2Type' source = 'class_AsmL::Method' target = 'class_AsmL::Type'/>
    <edge id = 'referenceEdge_Parameter2Type' source = 'class_AsmL::Parameter' target = 'class_AsmL::Type'/>
    <edge id = 'referenceEdge_Main2AsmLFile' source = 'class_AsmL::Main' target = 'class_AsmL::AsmLFile'/>
    <edge id = 'referenceEdge_Initially2VarTerm' source = 'class_AsmL::Initially' target = 'class_AsmL::VarTerm'/>
    <edge id = 'referenceEdge_StepExpression2Term' source = 'class_AsmL::StepExpression' target = 'class_AsmL::Term'/>
    <edge id = 'referenceEdge_StepForEach2InWhereHolds' source = 'class_AsmL::StepForEach' target = 'class_AsmL::InWhereHolds'/>
    <edge id = 'referenceEdge_MethodInvocation2MethodCallTerm' source = 'class_AsmL::MethodInvocation' target = 'class_AsmL::MethodCallTerm'/>
    <edge id = 'referenceEdge_UpdateRule2Term' source = 'class_AsmL::UpdateRule' target = 'class_AsmL::Term'/>
    <edge id = 'referenceEdge_UpdateVarRule2Term' source = 'class_AsmL::UpdateVarRule' target = 'class_AsmL::Term'/>
    <edge id = 'referenceEdge_UpdateFieldRule2VarTerm' source = 'class_AsmL::UpdateFieldRule' target = 'class_AsmL::VarTerm'/>
    <edge id = 'referenceEdge_UpdateMapRule2VarTerm' source = 'class_AsmL::UpdateMapRule' target = 'class_AsmL::VarTerm'/>
    <edge id = 'referenceEdge_ChooseRule2InWhereHolds' source = 'class_AsmL::ChooseRule' target = 'class_AsmL::InWhereHolds'/>
    <edge id = 'referenceEdge_ForallRule2InWhereHolds' source = 'class_AsmL::ForallRule' target = 'class_AsmL::InWhereHolds'/>
    <edge id = 'referenceEdge_ConditionalRule2Term' source = 'class_AsmL::ConditionalRule' target = 'class_AsmL::Term'/>
    <edge id = 'referenceEdge_ReturnRule2Term' source = 'class_AsmL::ReturnRule' target = 'class_AsmL::Term'/>
    <edge id = 'referenceEdge_AddRule2Term' source = 'class_AsmL::AddRule' target = 'class_AsmL::Term'/>
    <edge id = 'referenceEdge_RemoveRule2Term' source = 'class_AsmL::RemoveRule' target = 'class_AsmL::Term'/>
    <edge id = 'referenceEdge_MapType2Type' source = 'class_AsmL::MapType' target = 'class_AsmL::Type'/>
    <edge id = 'referenceEdge_TupletType2Type' source = 'class_AsmL::TupletType' target = 'class_AsmL::Type'/>
    <edge id = 'referenceEdge_SetType2Type' source = 'class_AsmL::SetType' target = 'class_AsmL::Type'/>
    <edge id = 'referenceEdge_SequenceType2Type' source = 'class_AsmL::SequenceType' target = 'class_AsmL::Type'/>
    <edge id = 'referenceEdge_Operator2Term' source = 'class_AsmL::Operator' target = 'class_AsmL::Term'/>
    <edge id = 'referenceEdge_MapTerm2Term' source = 'class_AsmL::MapTerm' target = 'class_AsmL::Term'/>
    <edge id = 'referenceEdge_TulpletTerm2Term' source = 'class_AsmL::TulpletTerm' target = 'class_AsmL::Term'/>
    <edge id = 'referenceEdge_PredicateTerm2InWhereHolds' source = 'class_AsmL::PredicateTerm' target = 'class_AsmL::InWhereHolds'/>
    <edge id = 'referenceEdge_EnumerateSet2Term' source = 'class_AsmL::EnumerateSet' target = 'class_AsmL::Term'/>
    <edge id = 'referenceEdge_RangeSet2Term' source = 'class_AsmL::RangeSet' target = 'class_AsmL::Term'/>
    <edge id = 'referenceEdge_AlgorithmSet2InWhereHolds' source = 'class_AsmL::AlgorithmSet' target = 'class_AsmL::InWhereHolds'/>
    <edge id = 'referenceEdge_EnumerateSequence2Term' source = 'class_AsmL::EnumerateSequence' target = 'class_AsmL::Term'/>
    <edge id = 'referenceEdge_RangeSequence2Term' source = 'class_AsmL::RangeSequence' target = 'class_AsmL::Term'/>
    <node id = 'class_AsmL::LocatedElement'>
      <data key = 'label'>class_AsmL::LocatedElement</data>
    </node>
    <node id = 'class_AsmL::Body'>
      <data key = 'label'>class_AsmL::Body</data>
    </node>
    <node id = 'class_AsmL::InWhereHolds'>
      <data key = 'label'>class_AsmL::InWhereHolds</data>
    </node>
    <node id = 'class_AsmL::AsmLFile'>
      <data key = 'label'>class_AsmL::AsmLFile</data>
    </node>
    <node id = 'class_AsmL::AsmLElement'>
      <data key = 'label'>class_AsmL::AsmLElement</data>
    </node>
    <node id = 'class_AsmL::VarDeclaration'>
      <data key = 'label'>class_AsmL::VarDeclaration</data>
    </node>
    <node id = 'class_AsmL::Namespace'>
      <data key = 'label'>class_AsmL::Namespace</data>
    </node>
    <node id = 'class_AsmL::Structure'>
      <data key = 'label'>class_AsmL::Structure</data>
    </node>
    <node id = 'class_AsmL::VarOrCase'>
      <data key = 'label'>class_AsmL::VarOrCase</data>
    </node>
    <node id = 'class_AsmL::Case'>
      <data key = 'label'>class_AsmL::Case</data>
    </node>
    <node id = 'class_AsmL::Class'>
      <data key = 'label'>class_AsmL::Class</data>
    </node>
    <node id = 'class_AsmL::VarOrMethod'>
      <data key = 'label'>class_AsmL::VarOrMethod</data>
    </node>
    <node id = 'class_AsmL::Enumeration'>
      <data key = 'label'>class_AsmL::Enumeration</data>
    </node>
    <node id = 'class_AsmL::Enumerator'>
      <data key = 'label'>class_AsmL::Enumerator</data>
    </node>
    <node id = 'class_AsmL::Function'>
      <data key = 'label'>class_AsmL::Function</data>
    </node>
    <node id = 'class_AsmL::Method'>
      <data key = 'label'>class_AsmL::Method</data>
    </node>
    <node id = 'class_AsmL::Parameter'>
      <data key = 'label'>class_AsmL::Parameter</data>
    </node>
    <node id = 'class_AsmL::Main'>
      <data key = 'label'>class_AsmL::Main</data>
    </node>
    <node id = 'class_AsmL::Initially'>
      <data key = 'label'>class_AsmL::Initially</data>
    </node>
    <node id = 'class_AsmL::Rule'>
      <data key = 'label'>class_AsmL::Rule</data>
    </node>
    <node id = 'class_AsmL::SkipRule'>
      <data key = 'label'>class_AsmL::SkipRule</data>
    </node>
    <node id = 'class_AsmL::Step'>
      <data key = 'label'>class_AsmL::Step</data>
    </node>
    <node id = 'class_AsmL::StepUntilFixPoint'>
      <data key = 'label'>class_AsmL::StepUntilFixPoint</data>
    </node>
    <node id = 'class_AsmL::StepExpression'>
      <data key = 'label'>class_AsmL::StepExpression</data>
    </node>
    <node id = 'class_AsmL::StepWhile'>
      <data key = 'label'>class_AsmL::StepWhile</data>
    </node>
    <node id = 'class_AsmL::StepUntil'>
      <data key = 'label'>class_AsmL::StepUntil</data>
    </node>
    <node id = 'class_AsmL::StepForEach'>
      <data key = 'label'>class_AsmL::StepForEach</data>
    </node>
    <node id = 'class_AsmL::MethodInvocation'>
      <data key = 'label'>class_AsmL::MethodInvocation</data>
    </node>
    <node id = 'class_AsmL::UpdateRule'>
      <data key = 'label'>class_AsmL::UpdateRule</data>
    </node>
    <node id = 'class_AsmL::UpdateVarRule'>
      <data key = 'label'>class_AsmL::UpdateVarRule</data>
    </node>
    <node id = 'class_AsmL::UpdateFieldRule'>
      <data key = 'label'>class_AsmL::UpdateFieldRule</data>
    </node>
    <node id = 'class_AsmL::UpdateMapRule'>
      <data key = 'label'>class_AsmL::UpdateMapRule</data>
    </node>
    <node id = 'class_AsmL::ChooseRule'>
      <data key = 'label'>class_AsmL::ChooseRule</data>
    </node>
    <node id = 'class_AsmL::ForallRule'>
      <data key = 'label'>class_AsmL::ForallRule</data>
    </node>
    <node id = 'class_AsmL::ConditionalRule'>
      <data key = 'label'>class_AsmL::ConditionalRule</data>
    </node>
    <node id = 'class_AsmL::ElseIf'>
      <data key = 'label'>class_AsmL::ElseIf</data>
    </node>
    <node id = 'class_AsmL::ReturnRule'>
      <data key = 'label'>class_AsmL::ReturnRule</data>
    </node>
    <node id = 'class_AsmL::AddRule'>
      <data key = 'label'>class_AsmL::AddRule</data>
    </node>
    <node id = 'class_AsmL::RemoveRule'>
      <data key = 'label'>class_AsmL::RemoveRule</data>
    </node>
    <node id = 'class_AsmL::Type'>
      <data key = 'label'>class_AsmL::Type</data>
    </node>
    <node id = 'class_AsmL::NamedType'>
      <data key = 'label'>class_AsmL::NamedType</data>
    </node>
    <node id = 'class_AsmL::MapType'>
      <data key = 'label'>class_AsmL::MapType</data>
    </node>
    <node id = 'class_AsmL::TupletType'>
      <data key = 'label'>class_AsmL::TupletType</data>
    </node>
    <node id = 'class_AsmL::SetType'>
      <data key = 'label'>class_AsmL::SetType</data>
    </node>
    <node id = 'class_AsmL::SequenceType'>
      <data key = 'label'>class_AsmL::SequenceType</data>
    </node>
    <node id = 'class_AsmL::Term'>
      <data key = 'label'>class_AsmL::Term</data>
    </node>
    <node id = 'class_AsmL::VarTerm'>
      <data key = 'label'>class_AsmL::VarTerm</data>
    </node>
    <node id = 'class_AsmL::Operator'>
      <data key = 'label'>class_AsmL::Operator</data>
    </node>
    <node id = 'class_AsmL::MapTerm'>
      <data key = 'label'>class_AsmL::MapTerm</data>
    </node>
    <node id = 'class_AsmL::TulpletTerm'>
      <data key = 'label'>class_AsmL::TulpletTerm</data>
    </node>
    <node id = 'class_AsmL::MethodCallTerm'>
      <data key = 'label'>class_AsmL::MethodCallTerm</data>
    </node>
    <node id = 'class_AsmL::NewInstance'>
      <data key = 'label'>class_AsmL::NewInstance</data>
    </node>
    <node id = 'class_AsmL::PredicateTerm'>
      <data key = 'label'>class_AsmL::PredicateTerm</data>
    </node>
    <node id = 'class_AsmL::ForAllTerm'>
      <data key = 'label'>class_AsmL::ForAllTerm</data>
    </node>
    <node id = 'class_AsmL::ExistsTerm'>
      <data key = 'label'>class_AsmL::ExistsTerm</data>
    </node>
    <node id = 'class_AsmL::AnyIn'>
      <data key = 'label'>class_AsmL::AnyIn</data>
    </node>
    <node id = 'class_AsmL::SetTerm'>
      <data key = 'label'>class_AsmL::SetTerm</data>
    </node>
    <node id = 'class_AsmL::EnumerateSet'>
      <data key = 'label'>class_AsmL::EnumerateSet</data>
    </node>
    <node id = 'class_AsmL::RangeSet'>
      <data key = 'label'>class_AsmL::RangeSet</data>
    </node>
    <node id = 'class_AsmL::AlgorithmSet'>
      <data key = 'label'>class_AsmL::AlgorithmSet</data>
    </node>
    <node id = 'class_AsmL::SequenceTerm'>
      <data key = 'label'>class_AsmL::SequenceTerm</data>
    </node>
    <node id = 'class_AsmL::EnumerateSequence'>
      <data key = 'label'>class_AsmL::EnumerateSequence</data>
    </node>
    <node id = 'class_AsmL::RangeSequence'>
      <data key = 'label'>class_AsmL::RangeSequence</data>
    </node>
    <node id = 'class_AsmL::Constant'>
      <data key = 'label'>class_AsmL::Constant</data>
    </node>
    <node id = 'class_AsmL::BooleanConstant'>
      <data key = 'label'>class_AsmL::BooleanConstant</data>
    </node>
    <node id = 'class_AsmL::IntegerConstant'>
      <data key = 'label'>class_AsmL::IntegerConstant</data>
    </node>
    <node id = 'class_AsmL::StringConstant'>
      <data key = 'label'>class_AsmL::StringConstant</data>
    </node>
    <node id = 'class_AsmL::NullConstant'>
      <data key = 'label'>class_AsmL::NullConstant</data>
    </node>
    <node id = 'package_AsmL'>
      <data key = 'label'>package_AsmL</data>
    </node>
  </graph>
  <graph id = 'PrimitiveTypesGraph' edgedefault = 'undirected'>
    <node id = 'dataType_String'>
      <data key = 'label'>dataType_String</data>
    </node>
    <node id = 'dataType_Integer'>
      <data key = 'label'>dataType_Integer</data>
    </node>
    <node id = 'dataType_Boolean'>
      <data key = 'label'>dataType_Boolean</data>
    </node>
    <node id = 'package_PrimitiveTypes'>
      <data key = 'label'>package_PrimitiveTypes</data>
    </node>
  </graph>
</graphml>
