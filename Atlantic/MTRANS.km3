-- @name		MTRANS 
-- @version		0.1
-- @domains		Model transformation
-- @authors		Hugo Bruneliere (hugo.bruneliere <at> gmail.com), Pierrick Guyard (pierrick.guyard <at> gmail.com)
-- @date		2005/08/10
-- @description	This metamodel describes MTRANS. The MTRANS project aims to supply a general framework for expressing model transformations. In order to be as general as possible, it is based on a meta-modeling approach (a meta-model is used to define the semantics of each model). The MTRANS framework is supplying a language and an environment to write models transformations. The language is composed by a fixed instruction set (conditional, loop, etc.) plus a part depending on the particular meta-models used. MTRANS was a precursor to QVT languages.

package MTRANS {

	class MetaClass{}
	
	class MetaModel {}
	
	class Module {
		attribute name : String;
		attribute mode : String;
		reference metaDest[*] : MetaModel;
		reference metaSource[*] : MetaModel;
		reference rules[1-*] container : Rule oppositeOf module;
	}
	
	class Rule {
		attribute isAbstract : Boolean;
		attribute isEntryPoint : Boolean;
		attribute name : String;
		reference module : Module oppositeOf rules;
		reference target[0-1] : MetaClass;
		reference source[0-1] : MetaClass;
		reference declaration[0-1] container : Variable oppositeOf rule;
		reference sections[1-*] container : Section oppositeOf rule;
		reference guard[0-1] container : Expression oppositeOf rule;
		reference inheritances[*] container : Inheritance oppositeOf rule;
	}
	
	class Inheritance {
		reference rule : Rule oppositeOf inheritances;
		reference expressions[*] container : Expression oppositeOf inheritance;
		reference inheritedRules[*] : Rule;
	}
	
	class Expression {
		attribute operator : String;
		reference inheritance : Inheritance oppositeOf expressions;
		reference rule : Rule oppositeOf guard;
		reference instruction : Instruction oppositeOf body;
	}	
	
	class Section {
		attribute kind : String;
		reference rule : Rule oppositeOf sections;
		reference instructions[1-*] container : Instruction oppositeOf section;
	}
	
	class Instruction {
		reference body container : Expression oppositeOf instruction;
		reference section : Section oppositeOf instructions;
	}
	
	class Variable {
		attribute name : String;
		reference rule : Rule oppositeOf declaration;
	}
			
}

package PrimitiveTypes {
	datatype Boolean;
	datatype String;
}