-- @name		Mining Mart
-- @version		1.0
-- @domains		Mining Mart
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/07/21
-- @description	This metamodel describes Mining Mart. "Mining Mart follows a typical metadata-driven software architecture,[...]. The Mining Mart MetaModel(M4) can be logically divided into two main parts, one managing information with regard to data modelling and the other one regarding case."
-- @see			M4 - The Mining Mart MetaModel
-- @see 		Authors: Anca Vaduva, Jörg-Uwe Kietz, Regina Zücker and Klaus R. Dittrich
-- @see 		ftp://ftp.ifi.unizh.ch/pub/techreports/TR-2001/ifi-2001.02.pdf
-- @see 		page 28, figure 9: The Mining Mart Metamodel

package MiningMart {

-- @begin SimplfiedMiningMart
-- @comment page 7, section 4, figure 4: Simplified UML
package SimplfiedMiningMart {

-- @comment "ModelElement is the base for all modeling metaclass in the UML. All other modeling metaclass are either directly or indirectly specialized from ModelElement." 
 class ModelElement {}
 
 -- @comment "Classifier is a general element that describes behavioral and structural features; it appears in several specific forms; that means, the class Classifier may be specialized as Class, DataType, Interface, Component, aso."
 class Classifier extends ModelElement {}
 class StructuralFeature extends ModelElement {}
 
 --@comment "A Class is a description of a set of objects that share the same attributes operations, methods, relationships, and semantics. Specializations in M4 of the UML class Class are ColumnSet and Concept"
 class Class extends Classifier {
 	attribute name : String;
 	reference attributes[1-*] container : Attribute oppositeOf "class"; 
 }

 class DataType extends Classifier {
 	reference "attribute" : Attribute oppositeOf has;
 } 
 
 class Attribute extends StructuralFeature {
 	reference "class" : Class oppositeOf attributes;
 	reference has : DataType oppositeOf "attribute";
 }

}
-- @end SimplfiedMiningMart

-- @begin DataRepresentation
-- @comment page 9, section 5, figure 5: The class diagramm of Mining Mart data representation
package DataRepresentation {
 
 -- @comment "An instance of the class Column defines a set of values in a result set, e.g., a view or a table."
 class Column extends Attribute {
 	attribute name : String;
 	reference dataType : DataType;
 	reference keys[*] : Key oppositeOf hasColumn;
 	reference belongsToColumnSet : ColumnSet oppositeOf hasColumn;
 	reference corespondsToBaseAttribute : BaseAttribute;
 	reference linkPackage[0-1] : LinkPackage oppositeOf column;
 }
 
 -- @comment  "A ColumnSet describes any general set of columns - typivally a table, view or snapshot."
 -- @comment "Constraint: ColumnSet points either to a Concept or a RelationShip."
 -- @comment "Constraint: There are ColumnSets which do not point to any concept but to a relationship- this is the case when the RelationShip has the multiplicity m:n, then it will be implemented as a separate table."
 class ColumnSet extends Class {
 	--reference name : String; including in the superclass
 	attribute number : Integer;
 	attribute file : String;
 	attribute dbConnectString : String;
 	attribute user : String;
 	reference hasColumn[1-*] : Column oppositeOf belongsToColumnSet; 
 	reference hasKey[1-*] : Key oppositeOf isAssociatedToColumnSet;
 	reference correspondsToConcept[0-1] : Concept oppositeOf correspondsToColumnSet;
 	reference  correspondsToRelationShip[0-1] : RelationShip  oppositeOf correspondsToColumnSet;
  	reference linkPackage[0-1] : LinkPackage oppositeOf columnSet;
  }
  
  -- @comment "ColumnStatistics contains statistic information for columns necessary during data mining."
 class ColumnStatistics {
  	attribute "unique" : Integer;
 	attribute missing : Integer;
 	attribute min : Integer;
 	attribute max : Integer;
 	attribute average : Integer;
 	attribute standarDeviation : Integer;
 	attribute distributionValue : String;
 	attribute distributionCount : Integer;
 	attribute distributionMin : Integer;
 	attribute distributionMax : Integer;
 	reference forColumn : Column;
 }
 
 --@comment "ColumnSetStatistics contains statistic information for ColumnSets."
 class ColumnSetStatistics extends ModelElement {
 	attribute allNumber : Integer;
 	attribute ordinalNumber : Integer;
 	attribute nominalNumber : Integer;
 	attribute timeNumber : Integer;
 	reference forColumnSet : ColumnSet;
 }
 
 class Snapshot extends ColumnSet {}
 class Table extends ColumnSet {}
 class View extends ColumnSet {}
 
 -- @comment The class Key, so its subtypes, represents "the corresponding  notions known from the relational model."
 class Key extends ModelElement {
 	attribute isUsedForIndex : Boolean;
 	reference hasColumn[1-*] : Column oppositeOf keys;
 	reference isAssociatedToColumnSet : ColumnSet oppositeOf hasKey;
 }
  
 class ForeignKey extends Key {
 	reference isConnectionTo[0-1] : Table;
 	reference correspondsToRelationShip[0-1] : RelationShip oppositeOf correspondsToForeignKey;
 }
 
 class PrimaryKey extends Key {}
 
 -- @comment "A Concept is the basic elment  of the conceptual data representation."
 -- @comment "Contraint: Each ColumnSet has a Conceptor or RelationShip but not each Concept or RelationShip points to a  ColumnSet has no correspondant on the database side"
 -- @comment "Contraint: For each instance of FromConcept association an instance of ToConcept association has to exist and conversely"
 class Concept extends Class, Parameter {
 	-- reference name : String;  ncluding in the superclass
 	attribute subConceptRestriction : String;
 	reference isA : Concept;
 	reference FromConcept : RelationShip oppositeOf FromConcept ;
  	reference ToConcept : RelationShip oppositeOf ToConcept;
  	reference correspondsToColumnSet[0-1] : ColumnSet oppositeOf correspondsToConcept;
 }
 
 -- @comment "A RelationShip expresses the connection existing between two concepts."
 -- @comment "Constraint: Each RelationShip corresponds to either a ColumnSet or a ForeignKey on the implemtation level. That  means, the association correspondsToForeignKey exist wirhout the association correspondsToColumnSet. However, when correspondsToColumnSetExists, it requires two ForeignKeys as well."
 -- @comment "Constraint: A Relationship cannot exist without FromConcept and ToConcept;
 class RelationShip extends ModelElement, Parameter {
 	--attribute name : String; including in the superclass Parameter
 	attribute subRelationShipRestriction : String;
 	attribute defined : String;
 	reference isA : RelationShip;
 	reference correspondsToForeignKey[1-*] : ForeignKey oppositeOf  correspondsToRelationShip;
 	reference correspondsToColumnSet[0-1] : ColumnSet oppositeOf correspondsToRelationShip;
 	reference FromConcept : Concept oppositeOf FromConcept;
 	reference ToConcept : Concept oppositeOf ToConcept;
 } 
 
 -- @comment "Contains feature of Concepts. It may be either a BaseAttribute or a MultiColumnFeature."
 class FeatureAttribute extends Attribute {
 	attribute name : String;
 	attribute relevanceForMining : Boolean;
 	reference attributeType : DataType;
 	reference belongsToConcept container : Concept;
 	reference correspondsToColumns[1-*] : Column;
 }
 
 -- @comment  " A BaseAttribute may have various mining relevant dtat types." 
 class BaseAttribute extends FeatureAttribute {
 	reference isPartMultiColumnFeature[0-1] : MultiColumnFeature oppositeOf consitsOfBaseAttributes;
 	reference domainDataType : DomainDataType oppositeOf baseAttributeD;
 }
 
 -- @comment "A MultiColumnFeature consits of a set BaseAttributes."
 class MultiColumnFeature extends FeatureAttribute {
 	reference consitsOfBaseAttributes[*] container : BaseAttribute oppositeOf isPartMultiColumnFeature;
 }
 
 -- @comment "Value is needed within arithmetc expressions and conditions used in operators like for e.g., segmentation operators." 
 class Value extends Attribute, Parameter {
 	--reference name :String; including in the superclass Parameter
 	reference domainDataType : DomainDataType;
 	reference belongsToUserInput[1-*] container : UserInput;
 	reference linkPackage[0-1] : LinkPackage oppositeOf value; 
 }
 
 -- @comment "Contains the set of values entered by users when specifying cases."
 class UserInput extends Class {
 	-- reference name : String; including in the superclass
 	reference containsValues[1-*] : Value;
 }
  
 -- @comment "All values of this attribute are ordered ."
 class Ordinal extends DomainDataType {}
 
 -- @comment "Scalar attributes are usually represented as numeric or date on the implementation level.."
 class Scalar extends Ordinal {}
 
 --  @comment  "It represents the absolute point of time."
 class Time extends Scalar {}
 
 --  @comment  "Has only two values : 0 or 1."
 class Binary extends Scalar, Nominal {}
 
 -- @comment "Has fixed small number of values."
 class Categorial extends Nominal {}
 
 -- @comment  "This kind of attributes is used for identification and is not suitable for mining."
 class KeyAttribute  extends Nominal {}
 
 -- @comment  "It represents the identification of an individual for which Time data collected."
 class TimeGroup extends KeyAttribute {}
 
 -- @comment  "This data type is used for geographical information system(GIS) and mining visualisation."
 class Spatial extends KeyAttribute {}

 -- @comment "It has only one possible value and thus it is not suitable for mining. Typically is the result of a selection."
 class Constant extends Nominal {}
 
 --@comment "It is necessarily bound to a Relationship and a Concept."
 class RoleRestriction extends Attribute {
 	attribute name : String;
 	reference restrictionForRelationShip : RelationShip;
 	reference restrictionForConcept : Concept;
 	reference restrictionToConcept : Concept;
 	attribute min : Integer;
 	attribute max : Integer;
 	reference belongsToConcept : Concept;
 }
 
 -- @comment "This class represents the domain specific data type of BaseAttribute."
 class DomainDataType extends DataType {
 	reference baseAttributeD : BaseAttribute oppositeOf domainDataType;
 }
  
 class Nominal extends DomainDataType {}
  
}
-- @end DataRepresentation

-- @begin CaseRepresentation
-- @comment page 20, section 6, figure 8: The class diagram of Mining Mart case representation.
package CaseRepresentation {

 -- @comment "A Case consits of many steps."
 class Case extends ModelElement {
 	attribute name : String;
 	attribute caseMode : Boolean;
 	reference caseInput : Parameter;
 	reference caseOutput : Concept;
 	attribute documentation : String;
 	reference listOfStep[1-*] container : Step oppositeOf belongsToCase;
 	reference population : Concept;
 	reference targetAttributes : FeatureAttribute;
 }
 
 -- @comment "Steps are parts of cases."
 class Step extends ModelElement {
 	attribute name : String;
 	attribute description : String;
 	reference belongsToCase : Case oppositeOf listOfStep;
 	reference embedsOperator : Operator;
 	reference predecessors[*] : Step;
 	reference successors[*] : Step;
 }

 -- @comment "LoopStep is a special kind of Step. It allows the iteration along more than one inpute element."
 class LoopStep extends Step {
 	reference iterationSet[*] ordered : FeatureAttribute;
 	reference outputSet[*] ordered : FeatureAttribute;
 }
 
 -- @comment "MultiStep is anoter special kind of Step. While LoopStep is an iteration over input elements, MultiStep is an iteration over output elements."
 class MultiStep extends Step {
 	attribute iterationCondition : String;
 }
 
 -- @comment "It is the superclass of all operators of Mining Mart."
 abstract class Operator extends ModelElement {
	attribute loopable :Boolean;
	attribute numberOfInputParameters : Integer;
	attribute numberOfOutputParameters : Integer;
	attribute manual : Boolean;
	attribute tool : String;
	reference input[1-*] ordered : Parameter;
	reference output[1-*] ordered : Parameter;
 	reference realizes : ExecutionElement;
 }
 
 -- @comment "Parameters are input or output values of Operators and thus may be instances of Value, Concept, RelationShip, FeatureElement."
 class Parameter {
 	attribute name : String;
 	attribute place : String;
 	attribute parameterType : ParameterType;
 	reference belongsToOperator : Operator;
 }
 
 -- @comment This enumeration allows the type of ParmeterType. However, we observe that the elements of enumeration ParameterType are the same that the childs of Parameter. There is, perhaps, a redundancy information.
 enumeration ParameterType {
 	literal Value;
 	literal Concept;
 	literal RelationShip;
 	literal FeatureAttribute;
  }
 
 -- @comment "The operator FeatureConstructuion creates a new feature for concept; on the implementation level that means a new attribute in a table or view."
 class FeatureConstruction extends Operator {
 	attribute scalingFactor : Integer;
 }
 
 class DataMinStep extends Operator {}
 class TimeOperator extends Operator {}
 class FeatureSelection extends Operator {}
 class MultiRelFeatureConstr extends Operator {}
 class RowSelection extends Operator {}
 
 class Agregation extends MultiRelFeatureConstr {}
 
 class Scaling extends FeatureConstruction {}
 class Discretization extends FeatureConstruction {}
 
 class Segmentation extends RowSelection {}
 class Sampling extends RowSelection {}
 
 
 class ExecutionElement {
 	reference source : DataObject oppositeOf source;
 	reference target : DataObject oppositeOf target;
 }
 
 class DataObject { 
 	reference source : ExecutionElement oppositeOf source;
 	reference target : ExecutionElement oppositeOf target;
 	reference linkPackageCaseRepresentation : LinkPackage oppositeOf dataObject;
 }
 
 class "MSL-Tool" extends ExecutionElement {}
 
 class TransformationGroup extends ExecutionElement {
 	reference transformation[*] container : Transformation oppositeOf transformationGroup;
 }
 
 -- @comment "A Transformation may be either a Function, or a StoredProcedure or the definition of SQL-Query."
 class Transformation extends ExecutionElement {
 	reference transformationGroup : TransformationGroup oppositeOf transformation;
 }
 
 class Function extends Transformation {
	attribute nameOf : String;
	attribute signature : String;
 }
 
 class StoredProcedure extends Transformation {
 	attribute nameOf : String;
  	attribute signature : String;
 }
 
 class SQLQuery extends Transformation {
 	reference select[1-*] : Column;  
 	reference from[1-*] : ColumnSet;
 	attribute where[*] : String;
 }
 
}
-- @end CaseRepresentation

-- @comment This enumeration allows to define the type of flow : Input or Output.
enumeration InOut {
 	literal Input;
 	literal OutPut;
 }


-- @comment This class enables to link the package CaseRepresentation and DataRepresentation for the elements : DataObject and ColumnSet, Column, Value. However, it exists others dependencies between those two packages.
-- @comment Constraint : it is either Value, or Column or ColumnSet. 
class LinkPackage {
	attribute type : InOut; -- the type is either Input or OutPut. So InOut is a enumeration of both possibilities.
	reference dataObject : DataObject oppositeOf linkPackageCaseRepresentation;
	reference value[0-1] : Value oppositeOf linkPackage;
	reference column[0-1] : Column oppositeOf linkPackage;
	reference columnSet[0-1] : ColumnSet oppositeOf linkPackage;
}

}

package PrimitiveTypes {
	datatype String;
	datatype Integer;
	datatype Real;
	datatype Boolean;
}
