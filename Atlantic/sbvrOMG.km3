package sbvr {

	class Actuality extends StateOfAffairs {
		
	}

	class StateOfAffairs extends Thing {
		
	}

	class Thing {
		reference name[*] : Name;
	}

	class Name extends Designation {
		
	}

	class Designation extends Representation {
		attribute implicitlyIsUnderstood[0-1] : Boolean;
		reference signifier : Expression;
		operation getSignifierText() : String;
		operation setSignifierText(value : String);
	}

	class Representation extends Actuality {
		reference meaning : Meaning;
		reference expression : Expression;
	}

	class Meaning extends Thing {
		reference representation[*] : Representation;
	}

	class Expression extends BindableTarget {
		
	}

	class BindableTarget extends Thing {
		
	}

	class AdoptedDefinition extends Definition {
		
	}

	class Definition extends Representation {
		
	}

	class Advice extends ElementOfGuidance {
		
	}

	class ElementOfGuidance extends Proposition {
		attribute isPracticable[0-1] : Boolean;
	}

	class Proposition extends Meaning {
		attribute isFalse[0-1] : Boolean;
		attribute isTrue[0-1] : Boolean;
		reference statement[*] : Statement;
		attribute isPossiblyTrue[0-1] : Boolean;
		attribute isObligatedToBeTrue[0-1] : Boolean;
		attribute isPermittedToBeTrue[0-1] : Boolean;
		attribute isNecessarilyTrue[0-1] : Boolean;
	}

	class Statement extends Representation {
		
	}

	class AdviceOfContingency extends AdviceOfPossibility {
		
	}

	class AdviceOfPossibility extends Advice {
		
	}

	class AdviceOfOptionality extends AdviceOfPermission {
		
	}

	class AdviceOfPermission extends Advice {
		
	}

	class AdviceStatement extends GuidanceStatement {
		
	}

	class GuidanceStatement extends Statement {
		
	}

	class AggregationFormulation extends ProjectingFormulation {
		
	}

	class ProjectingFormulation extends LogicalFormulation {
		reference projection : Projection;
	}

	class LogicalFormulation extends SemanticFormulation {
		
	}

	class SemanticFormulation extends Thing {
		
	}

	class Projection extends SemanticFormulation {
		reference constrainingFormulation[0-1] : LogicalFormulation;
		reference projectionVariable[1-*] : Variable;
		reference auxiliaryVariable[*] : AuxiliaryVariable;
	}

	class Variable extends BindableTarget {
		reference restrictingFormulation[0-1] : LogicalFormulation;
		reference projectionPosition[0-1] : PositiveInteger;
		reference rangedoverConcept[0-1] : Concept;
		attribute isUnitary[0-1] : Boolean;
	}

	class PositiveInteger extends NonnegativeInteger {
		
	}

	class NonnegativeInteger extends Integer {
		
	}

	class Integer extends Number {
		attribute value[0-1] : integer;
	}

	class Number extends Quantity {
		
	}

	class Quantity extends NounConcept {
		
	}

	class NounConcept extends Concept {
		
	}

	class Concept extends Meaning {
		reference attributiveNamespace[*] : AttributiveNamespace;
		reference definition[*] : Definition;
		reference moreGeneralConcept[*] : Concept;
		reference category[*] : Concept;
		reference essentialCharacteristic[*] : Characteristic;
		reference instance[*] : Thing;
		reference referenceScheme[*] : ReferenceScheme;
		reference impliedCharacteristic[*] : Characteristic;
		reference necessaryCharacteristic[*] : Characteristic;
		reference designation[*] : Designation;
		reference extension : Set;
	}

	class AttributiveNamespace extends Namespace {
		
	}

	class Namespace extends Thing {
		reference uri[*] : Uri;
	}

	class Uri extends Text {
		
	}

	class Text extends Expression {
		attribute value[0-1] : String;
	}

	class Characteristic extends FactType {
		
	}

	class FactType extends Concept {
		reference factTypeForm[*] : FactTypeForm;
		reference role[1-*] : FactTypeRole;
	}

	class FactTypeForm extends Representation {
		reference placeholder[1-*] : Placeholder;
	}

	class Placeholder extends Designation {
		reference startingCharacterPosition[0-1] : PositiveInteger;
	}

	class FactTypeRole extends Role {
		reference roleBinding[*] : RoleBinding;
	}

	class Role extends NounConcept {
		
	}

	class RoleBinding extends Thing {
		
	}

	class ReferenceScheme extends Thing {
		reference simplyUsedRole[*] : FactTypeRole;
		reference identifyingCharacteristic[*] : Characteristic;
		reference extensionallyUsedRole[*] : FactTypeRole;
	}

	class Set extends Thing {
		reference cardinality[0-1] : NonnegativeInteger;
		reference element[*] : Thing;
	}

	class AuxiliaryVariable extends Variable {
		
	}

	class AnswerNominalization extends ProjectingFormulation {
		
	}

	class AssociativeFactType extends FactType {
		
	}

	class AssortmentFactType extends FactType {
		
	}

	class AtleastnQuantification extends Quantification {
		reference minimumCardinality : NonnegativeInteger;
	}

	class Quantification extends LogicalFormulation {
		reference scopeFormulation[0-1] : LogicalFormulation;
	}

	class AtmostnQuantification extends Quantification {
		reference maximumCardinality : NonnegativeInteger;
	}

	class AtmostoneQuantification extends AtmostnQuantification {
		
	}

	class AtomicFormulation extends LogicalFormulation {
		reference roleBinding[*] : RoleBinding;
	}

	class BagProjection extends Projection {
		
	}

	class BinaryFactType extends FactType {
		
	}

	class BinaryLogicalOperation extends LogicalOperation {
		reference logicalOperand2[*] : LogicalFormulation;
		reference logicalOperand1[*] : LogicalFormulation;
	}

	class LogicalOperation extends LogicalFormulation {
		reference logicalOperand : LogicalFormulation;
	}

	class BodyOfSharedConcepts extends Thing {
		
	}

	class BodyOfSharedGuidance extends Thing {
		
	}

	class BodyOfSharedMeanings extends Set {
		reference elementaryFactType[*] : FactType;
	}

	class BusinessPolicy extends ElementOfGovernance {
		
	}

	class ElementOfGovernance extends ElementOfGuidance {
		attribute isDirectlyEnforceable[0-1] : Boolean;
	}

	class BusinessPolicyStatement extends GuidanceStatement {
		
	}

	class BusinessRule extends ElementOfGuidance, Rule {
		
	}

	class Rule extends Proposition {
		
	}

	class BusinessVocabulary extends Vocabulary {
		
	}

	class Vocabulary extends Set {
		
	}

	class CategorizationFactType extends SpecializationFactType {
		
	}

	class SpecializationFactType extends FactType {
		
	}

	class CategorizationScheme extends Thing {
		
	}

	class CategorizationType extends Concept {
		
	}

	class CharacteristicType extends ConceptType {
		
	}

	class ConceptType extends ObjectType {
		
	}

	class ObjectType extends Concept {
		reference categorizationScheme[*] : CategorizationScheme;
		reference categorizationType[*] : CategorizationType;
	}

	class ClosedLogicalFormulation extends ClosedSemanticFormulation, LogicalFormulation {
		
	}

	class ClosedSemanticFormulation extends SemanticFormulation {
		
	}

	class ClosedProjection extends Projection {
		
	}

	class CommunicationContent extends Representation {
		
	}

	class Community extends Thing {
		reference uri[*] : Uri;
		reference subcommunity[*] : Community;
	}

	class ConceptOfThingAsComposite extends Concept {
		
	}

	class ConceptOfThingAsContinuant extends Concept {
		
	}

	class ConceptOfThingAsDeveloped extends Concept {
		
	}

	class ConceptOfThingAsOccurrent extends Concept {
		
	}

	class ConceptOfThingAsPrimitive extends Concept {
		
	}

	class ConceptOfThingAsUnitary extends Concept {
		
	}

	class ConceptOfThingExistingDependently extends Concept {
		
	}

	class ConceptOfThingExistingIndependently extends Concept {
		
	}

	class ConceptualSchema extends Thing {
		
	}

	class Conjunction extends BinaryLogicalOperation {
		
	}

	class ContextOfThing extends Segmentation {
		
	}

	class Segmentation extends CategorizationScheme {
		
	}

	class ContextualizationFactType extends SpecializationFactType {
		
	}

	class ContextualizedConcept extends NounConcept {
		
	}

	class ContingencyStatement extends StatementOfAdviceOfPossibility {
		
	}

	class StatementOfAdviceOfPossibility extends AdviceStatement {
		
	}

	class DefiniteDescription extends IntensionalDefinition {
		
	}

	class IntensionalDefinition extends Definition {
		
	}

	class DerivableConcept extends Concept {
		
	}

	class Description extends Representation {
		
	}

	class DescriptiveExample extends Representation {
		
	}

	class Disjunction extends BinaryLogicalOperation {
		
	}

	class Equivalence extends BinaryLogicalOperation {
		
	}

	class ExactlynQuantification extends Quantification {
		reference cardinality : NonnegativeInteger;
	}

	class ExactlyoneQuantification extends ExactlynQuantification {
		
	}

	class ExclusiveDisjunction extends BinaryLogicalOperation {
		
	}

	class ExistentialQuantification extends AtleastnQuantification {
		
	}

	class ExplicitnessOfRepresentation extends CategorizationScheme {
		
	}

	class ExtensionalDefinition extends Definition {
		
	}

	class Facet extends ContextualizedConcept {
		
	}

	class Fact extends Proposition {
		
	}

	class FactModel extends Thing {
		
	}

	class FactSymbol extends Designation {
		
	}

	class FactTypeHasFactInFactModel {
		reference factType : FactType;
		reference fact : Fact;
		reference factModel : FactModel;
	}

	class FactTypeNominalization extends ProjectingFormulation {
		
	}

	class FactTypeRoleDesignation extends Designation {
		
	}

	class FactTypeTemplating extends CategorizationScheme {
		
	}

	class FormalRepresentation extends Representation {
		
	}

	class FundamentalConcept extends ObjectType {
		
	}

	class Icon extends NonverbalDesignation {
		
	}

	class NonverbalDesignation extends Designation {
		
	}

	class Implication extends BinaryLogicalOperation {
		reference consequent[*] : LogicalFormulation;
		reference antecedent[*] : LogicalFormulation;
	}

	class ImpossibilityStatement extends StructuralRuleStatement {
		
	}

	class StructuralRuleStatement extends RuleStatement {
		
	}

	class RuleStatement extends GuidanceStatement {
		
	}

	class IndividualConcept extends NounConcept, BindableTarget {
		
	}

	class InformalRepresentation extends Representation {
		
	}

	class InstantiationFormulation extends LogicalFormulation {
		
	}

	class IsfacetofFactType extends ContextualizationFactType {
		
	}

	class IspropertyofFactType extends AssociativeFactType {
		
	}

	class IsroleofFactType extends FactType {
		
	}

	class KindOfGuidanceStatement extends CategorizationScheme {
		
	}

	class Language extends Thing {
		
	}

	class LevelOfEnforcement extends Thing {
		
	}

	class LogicalFormulationKind extends ObjectType {
		
	}

	class LogicalNegation extends LogicalOperation {
		
	}

	class ModalFormulation extends LogicalFormulation {
		
	}

	class NandFormulation extends BinaryLogicalOperation {
		
	}

	class NecessityFormulation extends ModalFormulation {
		
	}

	class NecessityStatement extends StructuralRuleStatement {
		
	}

	class NonnecessityStatement extends StatementOfAdviceOfPossibility {
		
	}

	class NonobligationStatement extends StatementOfAdviceOfPermission {
		
	}

	class StatementOfAdviceOfPermission extends AdviceStatement {
		
	}

	class NorFormulation extends BinaryLogicalOperation {
		
	}

	class Note extends Representation {
		
	}

	class NounConceptNominalization extends ProjectingFormulation {
		
	}

	class NounForm extends FactTypeForm {
		
	}

	class NumericRangeQuantification extends Quantification {
		reference maximumCardinality : NonnegativeInteger;
		reference minimumCardinality : NonnegativeInteger;
	}

	class Objectification extends LogicalFormulation {
		
	}

	class ObligationFormulation extends ModalFormulation {
		
	}

	class ObligationStatement extends OperativeBusinessRuleStatement {
		
	}

	class OperativeBusinessRuleStatement extends RuleStatement {
		
	}

	class OperativeBusinessRule extends ElementOfGovernance, BusinessRule {
		reference levelOfEnforcement[*] : LevelOfEnforcement;
	}

	class OptionalityStatement extends StatementOfAdviceOfPermission {
		
	}

	class OwnedDefinition extends Definition {
		
	}

	class PartitiveFactType extends BinaryFactType {
		
	}

	class PermissibilityFormulation extends ModalFormulation {
		
	}

	class PermissionStatement extends StatementOfAdviceOfPermission {
		
	}

	class PossibilityFormulation extends ModalFormulation {
		
	}

	class PossibilityStatement extends StatementOfAdviceOfPossibility {
		
	}

	class PreferredDesignation extends Designation {
		
	}

	class ProhibitedDesignation extends Designation {
		
	}

	class ProhibitionStatement extends OperativeBusinessRuleStatement {
		
	}

	class PropositionNominalization extends LogicalFormulation {
		
	}

	class Question extends Meaning {
		
	}

	class QuestionNominalization extends ProjectingFormulation {
		
	}

	class RealworldNumericalCorrespondence extends CategorizationScheme {
		
	}

	class Reference extends Representation {
		
	}

	class RepresentationFormality extends Segmentation {
		
	}

	class Res extends Thing {
		
	}

	class RestrictedPermissionStatement extends OperativeBusinessRuleStatement {
		
	}

	class RestrictedPossibilityStatement extends StructuralRuleStatement {
		
	}

	class Rulebook extends Set {
		
	}

	class SemanticCommunity extends Community {
		reference speechCommunity[*] : SpeechCommunity;
	}

	class SpeechCommunity extends Community {
		
	}

	class SententialForm extends FactTypeForm {
		
	}

	class SetProjection extends Projection {
		
	}

	class Situation extends Thing {
		
	}

	class SituationalRole extends ObjectType, Role {
		
	}

	class SpeechCommunityAdoptsAdoptedDefinitionCitingReference {
		reference speechCommunity : SpeechCommunity;
		reference adoptedDefinition : AdoptedDefinition;
		reference "reference" : Reference;
	}

	class StateOfAffairsInvolvesThingInRole {
		reference stateOfAffairs : StateOfAffairs;
		reference thing : Thing;
		reference role : Role;
	}

	class StructuralBusinessRule extends BusinessRule, StructuralRule {
		
	}

	class StructuralRule extends Rule {
		
	}

	class SubjectField extends Thing {
		
	}

	class Term extends Designation {
		
	}

	class TerminologicalDictionary extends Thing {
		reference uri[*] container : Uri;
	}

	class ThingInContext extends Segmentation {
		
	}

	class UniversalQuantification extends Quantification {
		
	}

	class Viewpoint extends Thing {
		
	}

	class VocabularyNamespace extends Namespace {
		
	}

	class WhetherornotFormulation extends BinaryLogicalOperation {
		reference inconsequent[*] : LogicalFormulation;
		reference consequent[*] : LogicalFormulation;
	}
}

package PrimitiveTypes {

	datatype Boolean;

	datatype integer;

	datatype String;

	datatype Double;
}
